merge(G1, G2) {
	// the first node of the graph is the same
	FOR every node N in G2 DO
		IF N is not visited then
			enqueue (null, N) to Q;

			// Do a Bredth First Search on G2
			WHILE (Q.size() > 0 && !hasConflict) DO
				n2_parent = Q.dequeue();
				n2 = Q.dequeue();
				update n2 to be isVisited;
				
				// This means the node has no incoming edges
				IF n2_parent == null THEN
					// This would be a little risky because parent
					// is null 
					n1 = get_corresponding_node(G1, G2, n2, null);
					IF n1 == null THEN
						n1 = new Node(n2);
						add n1 to G1 and update related info in G1;
					FI
					update info of n1 to mark n1 and n2 are counterpart
				ELSE
					n1_parent = get_corresponding_node(n2_parent);
					// Since we always make sure the parent node has
					// already been merged
					assert(n1_parent != null);
					n1 = get_corresponding_node(G1, G2, n2, n1_parent);
					IF n1 == null THEN
						n1 = new Node(n2);
						add n1 to G1 and update related info in G1;
					FI
					update info of n1 to mark n1 and n2 are counterpart
				FI

				// n1 & n2 are already merged here
				FOR all outgoing edges (n2,n2_next) DO
					IF n2_next is visited THEN
						n1_next = get_corresponding_node(G1, G2, n2_next, n1);
						assert (n1_next != null);
						IF edge(n1, n1_next) is legal THEN
							update (n1, n1_next) in G1
						ELSE
							report conflict;
						FI
					ELSE
						add n2 to Queue;
						add n2_next to Queue;
					FI
				DONE
			DONE
		FI	
	DONE
}


// Should return node1 if there is a corresponding node in G1,
// or null if there is none
get_corresponding_node(G1, G2, node2, node1_parent) {
	IF node2 is visited THEN
		return the equivalent node;
	FI
	IF node1_parent == null THEN
		LET candidate_nodes <- nodes that have same hash as node2;
		IF candidate_nodes is empty THEN
			return null;
		ELSE
			LET n1 <- node in candidate_nodes that is most similar
						to node2 (based on get context_similarity)
			return n1;
		FI
	ELSE
		IF node1_parent the same outgoing nodes
		LET candidate_nodes <- nodes that have same hash as node2;
		FOR those nodes 
	FI
}


// Traverse down depth level to calculate the similarity score
// of both nodes
get_context_similarity(G1, G2, node1, node2, depth) {
	for all node

}
