merge(G1, G2) {
	// the first node of the graph is the same
	FOR every node N in G2 DO
		IF N is not visited then
			enqueue (null, N) to Q;

			// Do a Bredth First Search on G2
			WHILE (Q.size() > 0) DO
				n2_parent = Q.dequeue();
				n2 = Q.dequeue();
				
				// This means the node has no incoming edges
				IF n2_parent == null then
					
				FI
			DONE
		FI	
	DONE
}


// Should return node1 if there is a corresponding node in G1,
// or null if there is none
get_corresponding_node(G1, G2, node2) {

}


// Traverse down depth level to calculate the similarity score
// of both nodes
get_context_similarity(G1, G2, node1, node2, depth) {
	for all node

}
